---
title: 索引
date: 2022/03/15 21:27:09
math: true
categories:
  - [mysql]
tags:
  - []
---
# MySQL 索引

## 索引概述

> MySQL官方对索引的定义为: **是帮助 MySQL 高效获取数据的数据结构。**

索引的本质: 索引是数据结构 (空间换时间)。你可以简单理解为 “排好序的快速查找数据结构 "，满足特定查找算法。这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法。
**索引是在存储引擎中实现的，因此每种存储引擎的索引不一定完全相同**，并且**每种存储引擎不一定支持所有索引类型**。同时，存储引擎可以定义每个表的 **最大索引数** 和 **最大索引长度**。所有存储引擎支持每个表至少 16 个索引，总索引长度至少为 256 字节。有些存储引擎支持更多的索引数和更大的索引长度。

## 索引的优点

1. 类似大学图书馆建书目索引，提高数据检索的效率，降低,数据库的IO成本，这也是创建索引最主要的原因
2. 通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。
3. 在实现数据的参考完整性方面，可以加速表和表之间的连接。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。
4. 在使用分组和排序子句进行数据查询时，可以显著减少查询中分组和排序的时间，降低了 CPU 的消耗。

## 索引的缺点

1. 创建索引和维护索引要耗费时间，并且随着数据量的增加，所耗费的时间也会增加。Ⅰ
2. 索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，存储在磁盘上，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。
3. 然索引大大提高了查询速度，同时却会降低更新表的速度。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。

## 索引的分类

MySQL 的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。

- 从 **功能逻辑** 上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。
- 按照 **物理实现** 方式，索引可以分为 2 种:聚簇索引和非聚簇索引。
- 按照 **作用字段个数** 进行划分，分成单列索引和联合索引。

1. **普通索引**

   在创建普通索引时，不附加任何限制条件，只是用于提高查询效率。这类索引可以创建在任何数据类型中，其 E 是否唯一和非空，要由字段本身的完整性约束条件决定。建立索引以后，可以通过索引进行查询。例如，在表 student 的字段 name 上建立一个普通索引，查询记录时就可以根据该索引进行查询。

2. **唯一性索引**
   使用 `UNIQUE 参数`可以设置索引为唯一性索引，在创建唯一性索引时，限制该索引的值必须是唯一的，但允许有空值。在一张数据表里可以有多个唯一索引。

3. **主键索引**

   主键索引就是一种特殊的唯一性索引，在唯一索引的基础上增加了不为空的约束，也就是 `NOT NULL+UNIQUE`，一张表里最多只有一个主键索引。因为：这是由主键索引的物理实现方式决定的，因为数据存储在文件中只能按照一种顺序进行存储4.单列索引。

4. **单列索引**

   在表中的单个字段上创建索引。单列索引只根据该字段进行索引。单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段即可。一个表可以有多个单列索引。

5. **多列索引**

   多列索引是在表的多个字段组合上创建一个索引。该索引指向创建时对应的多个字段，可以通过这几个字段进行查询，但是只有查询条件中使用了这些字段中的第一个字段时才会被使用。例如，在表中的字段 id、name 和 gender 上建立一个多列索引 idx_id_name_gender，只有在查询条件中使用了字段 id 时该索引才会被使用。使用组合索引时遵循最左前缀集合。

6. **全文索引**

   全文索引(也称全文检索）是目前搜索引擎使用的一种关键技术。它能够利用【分词技术】等多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。全文索引非常适合大型数据集，对于小的数据集，他的用处比较小。

   使用参数 FULLTEXT 可以设置索引为全文索引。使用参数FULLTEXT可以设置索引为全文索引。在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引只能创建在 `CHAR`、`VARCHAR` 或 `TEXT` 类型及其系列类型的字段上，**查询数据量较大的字符串类型的字段时，使用全文索引可以提高查询速度**。例如，表 student 的字段 information 是 TEXT 类型 , 该字段包含了很多文字信息。在字段 information 上建立全文索引后，可以提高查询字段 information 的速度。

   全文索引典型有两种类型：**自然语言的全文检索** 和 **布尔全文检索**。

   自然语畜搜索引擎将计算每一个文档对象和查询的相关度。这里，相关度是基于匹配的关键词的个数，以及关键词在文档中出现的次数。在整个索引中出现次数越少的词语，匹配时的相关度就越高。相反，非常常见的单词将不会被搜索，如果一个词语的在超过 50% 的记录中都出现了，那么自然语言的搜索将不会搜索这类词语。

7. **空间索引**

   使用参数 SPATIAL 可以设置索引为空间索引。空间索引只能建立在空间数据类型上，这样可以提高系统获取空间数据的效率。MySQL 中的空间数据类型包括 `GEOMETRY`、`POINT`、`LINESTRING` 和 `POLYGON` 等。**目前只有 MyISAM 存储引擎支持空间检索**，而且**索引的字段不能为空值**。

## 创建索引

MySQL支持多种方法在单个或多个列上创建索引:

1. 在创建表的定义语句 `CREATE TABLE` 中指定索引列。
2. 使用 `ALTER TABLE` 语句在存在的表上创建索引。
3. 使用 `CREATE INDEX` 语句在已存在的表上添加索引。

### 第一种

```sql
CREATE TABLE users {
   ....
   [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] {col_name [length]}[ASC | DESC]
}
```

> 如果使用全文索引查询不能使用 LIKE

```sql
SELECT * FROM table_name WHERE MATCH(全文索引) AGAINST("查询字符串");
```

### 第二种

```sql
ALTER TABLE table_name ADD [INDEX | UNIQUE | FULLTEXT | SPATIAL] index_name(字段);
```

## 查看索引

### 第一种

```sql
SHOW CREATE TABLE book;
```

### 第二种

```sql
SHOW INDEX FROM book;
```

## 需要的设计原则

> 为了使索引的使用效率更高，在创建索引时，必须考虑在哪些字段上创建索引和创建什么类型的索引。**索引设计不合理或者缺少索引都会对数据库和应用程序的性能造成障碍**。高效的索引对于获得良好的性能非常重要。设计索引时，应该考虑相应准则。

### 字段的数值有唯一性的限制

索引本身可以起到约束的作用，比如唯一索引、主链索引都是可以起到唯一性约束的，因此在我们的数据表中，**如果某个字段是唯一性的，就可以直接创建唯一性索引，或者主键索引**。这样可以更快速地通过该索引来确定某条记录。

### 频繁作为 WHERE 查询条件的字段

某个字段在 SELECT 语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。

### 经常被 Group BY 和 ORDER BY 的列

索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要对分组或者排序的字段进行索引。如果待排序的列有多个，那么可以在这些列上建立组合索引。

### UPDATE、DELETE 的 WHERE 条件列

对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。**如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护 **。

### DISTINCT 字段需要创建索引

有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。

#### 多表 JOIN 连接操作时，创建索引

> 在连接表的时候连接条件字段类型保持一致否则使用隐式转换会出现索引失效。

1. 连接表的数量尽量不要超过 3 张，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。
2. 对 WHERE 条件创建索引，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。
3. 对用于连接的字段创建索引，并且该字段在多张表中的类型必须一致。比如 course_id 在 student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。

#### 使用列的类型小的创建索引

这里所说的类型大小指的就是该类型表示的数据范围的大小。

我们在定义表结构的时候要显式的指定列的类型，以整数类型为例，有 TININT、MEDIUMINT、INT、BIGINT 等，它们占用的存储空间依次递增，能表示的整数范围当然也是依次递增。如果我们想要对某个整数列建立索引的话，**在表示的整数范围允许的情况下，尽量让索引列使用较小的类型**，比如我们能使用 INT 就不要使用 BIGINT，能使用 MEDIUMINT 就不要使用 INT。这是因为:

1. 数据类型越小，在查询时进行的比较操作越快
2. 数据类型越小，索引占用的存储空间就越少，**在一个数据页内就可以放下更多的记录，从而减少磁盘 I/O 带来的性能损耗**，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。

这个建议对于表的**主键来说更加适用**，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的 I/O.

### 使用字符串前缀创建索引

假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，那就意味着在对应的 B+ 树中有这么两个问题:

1. B+ 树索引中的记录需要把该列的完整字符串存储起来，更费时。而且字符串越长，在索引中占用的存储空间越大。
2. 如果 B+ 树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间。

我们可以通过截取字段的前面一部分内容建立索引，这个就叫前缀索引。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值。既节约空间，又减少了字符串的比较时间，还大体能解决排序的问题。

例如，TEXT 和 BLOG 类型的字段，进行全文检索会很浪费时间，如果只检索字段前面的若干字符，这样可以提高检索速度。

问题是，截取多少呢?截取得多了，达不到节省索引存储空间的目的;截取得少了，重复内容太多，字段的散列度(选择性)会降低。怎么计算不同的长度的选择性呢?

```sql
SELECT count(distinct left(列名, 索引长度)) / count(*) form table_name;
```

**例子**

```sql
SELECT count(distinct left(address, 10)) / count(*) form table_name;
```

索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90% 以上。

### 区分度高的列适合作为索引

列的基数指的是某一列中不重复数据的个数，比方说某个列包含值 2，5，8，2，5，8，2，5，8，虽然有 9 条记录，但该列的基数却是 3。也就是说，在记录行数一定的情况下，列的基数越大，该列中的值越分散;列的基数越小，该列中的值越集中。这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列建立索引，为基数太小列的建立索引效果可能不好。

列的基数指的是某一列中不重复数据的个数，比方说某个列包含值2，5，8，2，5，8，2，5，8，虽然有 9 条记录，但该列的基数却是3。也就是说，**在记录行数一定的情况下，列的基数越大，该列中的值越分散;列的基数越小，该列中的值越集中**。这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列建立索引，为基数太小列的建立索引效果可能不好。
可以使用公式 select count(distinct a)/count(*) from t1 计算区分度，越接近 1 越好，一般超过 33% 就算是比较高效的索引了。
拓展: 联合索引把区分度高 (散列性高) 的列放在前面。

### 使用最频繁的列放到联合索引的左侧

这样也可以较少的建立一些索引。同时，由于"最左前缀原则"，可以增加联合索引的使用率。

### 在多个字段都要创建索引的情况下，联合索引优于单值索引

### 限制索引的数目

在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议 **单张表索引数量不超过 6 个**。原因:

1. 每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。
2. 索引会影响 INSERT、DELETE、UPDATE 等语句的性能，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。
3. 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加 MySQL 优化器生成执行计划时间，降低查询性能。

### 那些情况不适合创建索引

#### 在 where 中使用不到的字段，不要设置索引

WHERE 条件（包括 GROUP BY、ORDER BY) 里用不到的字段不需要创建索引，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的。

#### 数据量小的表最好不要使用索引

如果表记录太少，比如少于 1000 行，那么是不需要创建索引的。表记录太少，是否创建索引对查询效率的影响并不大。甚至说，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。

#### 有大量重复数据的列不要使用索引

在条件表达式中经常用到的不同值较多的列上建立索引，但字段中如果有大量重复数据，也不用创建索引。比如在学生表的 "“性别 "" 字段上只有 “男 " 与 " 女 " 两个不同值，因此无须建立索引。如果建立索引，不但不会提高查询效率，反而会严重降低数据更新速度。

#### 避免对经常更新的表创建过多的索引

1. 第一层含义:频繁更新的字段不一定要创建索引。因为更新数据的时候，也需要更新索引，如果索引太多，在更新索引的时候也会造成负担，从而影响效率。Ⅰ

2. 第二层含义:避免对经常更新的表创建过多的索引，并且索引中的列尽可能少。此时，虽然提高了查询速度，同时却会降低更新表的速度。

#### 不建议用无序的值作为索引

例如身份证、UUID(在索引比较时需要转为 ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。

#### 删除不再使用和很少使用的索引

表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们副除，从而减少索引对更新操作的影响。

#### 不要定义冗余或重复索引

- 冗余索引

  有时候有意或者无意的就对同一个列创建了多个索引，比如: index(a,b,c) 相当于 index(a)、index(a,b).index(a,b,c)。

- 重复索引

  在一个字段上重复定义不同类型的索引

## 总结

**索引是一把双刃剑，可提高查询效率, 但也会降低插入和更新的速度并占用磁盘空间。**

选择索引的最终目的是为了使查询的速度变快，上面给出的原则是最基本的准则，但不能拘泥于上面的准则，大家要在以后的学习和工作中进行不断的实践，根据应用的实际情况进行分析和判断，选择最合适的索引方式。
