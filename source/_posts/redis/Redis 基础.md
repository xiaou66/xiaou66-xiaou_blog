---
title: Redis 基础
date: 2022/03/07 19:54:37
math: true
categories:
  - [redis]
---
# Redis 基础

## 目前为什么都用 Redis 作为缓存数据库？

Redis 具有一下特点

1. **读写性能优异**
2. **数据类型丰富**
3. **原子性**
4. **丰富的特性**
5. **持久化**
6. **支持发布/订阅模式**
7. **分布式**

## Redis 的使用场景

### 热点数据缓存

对数据的缓存是 Redis 最常见的场景之一，因为 Redis 的速度快而且支持事务保证在使用的时候的数据的一致性。

作为缓存使用时，一般有两种方式保存数据: 

1. 在读取前，先去读取 Redis，如果没有数据，读取数据库，将读取到的数据缓存到 Redis 中。
2. 插入数据，同时写入 Redis 。

**方案一**

实施起来简单，但是要注意 **避免缓存击穿** 和 **数据的实时性相对会差一点**

**方案二**

数据实时性强，但是开发时不便于统一处理。

### 限时业务的运用

redis 中可以使用 `expire` 命令设置一个键的生存时间，到时间后 redis 会删除它。利用这一特性可以运用在限时的优惠活动信息、验证码等业务场景。

### 计数器相关问题

redis 由于 incrby 命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。

### 分布式锁

这个主要利用 redis 的 `setnx` 命令进行，`setnx："set if not exists"` 就是如果不存在则成功设置缓存同时返回 1，否则返回 0 ，这个特性在很多后台中都有所运用，服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过 `setnx` 设置一个 lock， 如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个 lock 加一个过期时间，比如说 30 分钟执行一次的定时任务，那么这个过期时间设置为小于 30 分钟的一个时间就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。

在分布式锁的场景中，主要用在比如秒杀系统等。

### 延时操作

比如在订单生产后我们占用了库存，10 分钟后去检验用户是否真正购买，如果没有购买将该单据设置无效，同时还原库存。 由于 redis 自 2.8.0 之后版本提供 Keyspace Notifications 功能，允许客户订阅 Pub/Sub 频道，以便以某种方式接收影响 Redis 数据集的事件。 所以我们对于上面的需求就可以用以下解决方案，我们在订单生产时，设置一个 key，同时设置 10 分钟后过期， 我们在后台实现一个监听器，监听 key 的实效，监听到 key 失效时将后续逻辑加上。

### 排行榜

可以借助 redis 的 SortedSet 进行对热点排行榜进行排序。

### 关系网存储

Redis 利用集合的一些命令，比如求交集、并集、差集等。

在微博应用中，每个用户关注的人存在一个集合中，就很容易实现求两个人的共同好友功能。

### 简单队列

可以利用 Redis 的 list 结构中的 `LPUSH` `RPOP` 实现队列。

## Redis 数据类型

Redis 所有的 key（键）都是字符串。我们在谈基础数据结构时，讨论的是存储值的数据类型，主要包括常见的 6 种数据类型，分别是：String、List、Set、Zset、Hash、bitmap。

### String

#### 命令使用

| 命令   | 使用             | 描述                    |
| ------ | ---------------- | ----------------------- |
| GET    | GET key          | 获取存储在给定键中的值  |
| SET    | SET key value    | 设置存储在给定键中的值  |
| DEL    | DEL key          | 删除存储在给定键中的值  |
| INCR   | INCR key         | 将键存储的值加 1        |
| DECR   | DECR key         | 将键存储的值减 1        |
| INCRBY | INCRBY key value | 将键存储的值加 value 值 |
| DECRBY | INCRBY key value | 将键存储的值减 value 值 |

#### 使用场景

1. **缓存**： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到 redis 中，redis 作为缓存层，mysql 做持久化层，降低 mysql 的读写压力。
2. **计数器**：redis 是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。

3. **session**：常见方案 spring session + redis 实现 session 共享

### List 列表

> Redis 中的 List 其实就是链表（Redis 用双端链表实现 List）

使用 List 结构，我们可以轻松地实现队列功能。List 的另一个应用就是消息队列，可以利用 List 的 PUSH 操作，将任务存放在 List 中，然后工作线程再用 POP 操作将任务取出进行执行。

#### 命令使用

| 命令   | 使用                         | 描述                                                         |
| ------ | ---------------------------- | ------------------------------------------------------------ |
| RPUSH  | RPUSH key value              | 将给定值推入到列表右端                                       |
| LPUSH  | LPUSH key value              | 将给定值推入到列表左端                                       |
| RPOP   | RPOP key                     | 从列表的右端弹出一个值，并返回被弹出的值                     |
| LPOP   | LPOP key                     | 从列表的左端弹出一个值，并返回被弹出的值                     |
| LRANGE | LRANGE key 开始位置 结束位置 | 获取列表在给定范围上的所有值                                 |
| LINDEX | LINEX key index              | 通过索引获取列表中的元素。你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。 |

#### 使用列表的技巧

- lpush + lpop = Stack(栈)
- lpush + rpop = Queue（队列）
- lpush + ltrim = apped Collection（有限集合）
- lpush + brpop = Message Queue（消息队列）

### Set 集合

> Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。

Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。

#### 命令使用

| 命令    | 使用                     | 描述               |
| ------- | ------------------------ | ------------------ |
| SADD    | 向集合添加一个或多个成员 | SADD key value     |
| SCARD   | 获取集合的成员数         | SCARD key          |
| SMEMBER | 返回集合中的所有成员     | SMEMBER key member |

#### 实战场景

1. 标签，给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签可以推荐关注的事或者关注的人。
2. 点赞或点踩收藏

### Hash 散列

> Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。

#### 命令使用

| 命令    | 使用                          | 简述                       |
| ------- | ----------------------------- | -------------------------- |
| HSET    | HSET hash-key sub-key1 value1 | 添加键值对                 |
| HGET    | HGET hash-key key1            | 获取指定散列键的值         |
| HGETALL | HGETALL hash-key1             | 获取散列中包含的所有键值对 |

#### 实战场景

- **缓存**： 能直观，相比string更节省空间，的维护缓存信息，如用户信息，视频信息等。

### Zset 有序集合

> Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。

有序集合的成员是唯一的,但分数(score)却可以重复。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。

#### 命令使用

| 命令            | 使用                                | 简述                                                 |
| --------------- | ----------------------------------- | ---------------------------------------------------- |
| ZADD            | ZADD zset-key 178 member1           | 将一个带有给定分值的成员添加到哦有序集合里面         |
| ZRANGE          | ZRANGE zset-key 0 -1 withcores      | 返回指定范围的列表 (升序)                            |
| ZREM            | ZREM zset-key member1               | 如果给定元素成员存在于有序集合中，那么就移除这个元素 |
| ZREVRANGE       | ZRANGE zset-key 0 -1 withcores      | 返回指定范围的列表 (降序)                            |
| ZSCORE          | ZSCORE zset-key key                 | 返回指定的 score                                     |
| ZREMRANGEBYRANK | ZREMRANGEBYRANK zset-key start stop | 移除有序集中，指定排名(rank)区间内的所有成员         |

#### 使用场景

**排行榜**：有序集合经典使用场景。例如小说视频等网站需要对用户上传的小说视频做排行榜，榜单可以按照用户关注数，更新时间，字数等打分，做排行

### Bitmap

> bitmap 存储的是连续的二进制数字（0 和 1），通过 bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 bitmap 本身会极大的节省储存空间。

#### 命令使用

| 命令     | 使用                       | 简述                                                         |
| -------- | -------------------------- | ------------------------------------------------------------ |
| SETBIT   | SETBIT key offset value    | 设置或者清空 key 的value(字符串)在offset处的bit值(值为0或1)  |
| GETBIT   | getbit key offset          | getbit 只是返回特定 bit 位的值。如果试图获取的 bit 位在当前字串长度范围外，该命令返回 0 |
| BITCOUNT | bitcount key [start] [end] | 获取 Bitmaps 指定范围值为 1 的个数                           |